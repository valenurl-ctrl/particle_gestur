<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title>Morfing Partikel (Kontrol Tangan)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 200px; height: 150px; z-index: 2; border: 1px solid #333; transform: scaleX(-1); opacity: 1; background: #000; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.6); }
        
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 10; color: white;
            background: rgba(0, 0, 0, 0.5); padding: 12px; border-radius: 8px; border: 1px solid #444;
            max-width: 380px;
        }
        /* small watermark inside the UI panel, top-right */
        .watermark {
            position: absolute;
            top: 6px;
            right: 8px;
            font-size: 11px;
            color: rgba(255,255,255,0.7);
            opacity: 0.9;
            pointer-events: none;
            user-select: none;
            font-weight: 600;
            letter-spacing: 0.2px;
        }
        /* Color panel for particle palettes (bottom-left, compact) */
        /* Place shape panel at bottom-left and color panel to its right to avoid stacking */
        #shape-panel { position: fixed; bottom: 20px; left: 20px; z-index: 1100; display: flex; align-items: center; gap: 8px; 
            background: rgba(0,0,0,0.32); padding: 8px; border-radius: 6px; border: 1px solid #444; flex-wrap: wrap; max-width: 180px; }
        #color-panel { position: fixed; bottom: 20px; left: 220px; z-index: 1100; display: flex; flex-direction: column; align-items: flex-start; gap: 6px; 
            background: rgba(0,0,0,0.35); padding: 8px; border-radius: 6px; border: 1px solid #444; flex-wrap: nowrap; max-width: 420px; }
        .color-label { font-size: 13px; color: #fff; padding: 4px 8px; border-bottom: 1px solid rgba(255,255,255,0.06); margin-bottom:6px; width:100%; }
        .shape-label { font-size: 13px; color: #fff; padding: 6px 8px; border-right: 1px solid rgba(255,255,255,0.06); margin-right: 8px; }

        /* Arrange buttons into neat responsive grids */
        .color-buttons, .shape-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(84px, 1fr));
            gap: 6px;
            align-items: center;
        }

        .color-buttons button, .shape-buttons button {
            width: 100%;
            box-sizing: border-box;
            padding: 6px 8px;
            margin: 0;
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        button {
            background: transparent; border: 1px solid #00ffff; color: #00ffff;
            padding: 8px 12px; margin: 5px; cursor: pointer; transition: 0.3s;
            text-transform: uppercase; font-weight: bold; font-size: 12px;
        }
        button:hover, button.active { background: #00ffff; color: #000; box-shadow: 0 0 10px #00ffff; }
        .status { margin-top: 10px; font-size: 12px; color: #aaa; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="watermark">@v4lenn_nn</div>
        <h3>SISTEM PARTIKEL</h3>
        <p>Pake jari lu buat ngontrol partikel</p>
        <!-- shape and color panels moved to bottom-left for less clutter -->
        <div class="status" id="status">Tunggu Bentar . . . </div>
    </div>

    <video id="video-feed" playsinline></video>
    
    <div id="canvas-container"></div>

    <!-- Bottom-left shape panel -->
    <div id="shape-panel">
        <div class="shape-label">Bentuk Partikel</div>
        <div class="shape-buttons">
            <button onclick="setShape('sphere', this)">Bola</button>
            <button onclick="setShape('heart', this)">Hati</button>
            <button onclick="setShape('saturn', this)">Saturnus</button>
            <button onclick="setShape('flower', this)">Bunga</button>
            <button onclick="setShape('fireworks', this)">Kembang Api</button>
            <button onclick="setShape('free', this)">Random</button>
        </div>
    </div>

    <!-- Bottom-left color panel -->
    <div id="color-panel">
        <div class="color-label">Warna</div>
        <div class="color-buttons">
            <button id="btn-rgb7" onclick="setPalette('rgb7')">RGB</button>
            <button id="btn-red" onclick="setPalette('red')">Merah</button>
            <button id="btn-cyan" onclick="setPalette('cyan')">Cyan</button>
            <button id="btn-orange" onclick="setPalette('orange')">Orange</button>
            <button id="btn-green" onclick="setPalette('green')">Hijau</button>
            <button id="btn-blue" onclick="setPalette('blue')">Biru</button>
            <button id="btn-purple" onclick="setPalette('purple')">Ungu</button>
            <button id="btn-white" onclick="setPalette('white')">Putih</button>
            <button id="btn-pink" onclick="setPalette('pink')">Pink</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.08;
        const CAM_Z = 6;
        
        // --- STATE ---
        let currentShape = 'sphere';
        let targetPositions = [];
        let particles;
        let geometry;
        let material;
        let scene, camera, renderer;
        let time = 0;
        
        // Hand Interaction State
        let handPresent = false;
        let handOpenness = 0.0; // 0 = closed, 1 = open
        let handX = 0; // -1 to 1
        let handY = 0; // -1 to 1
        // Color & motion smoothing state
        let targetColors = null;
        const COLOR_LERP = 0.04; // speed of color transitions (0..1)

        // Per-particle motion params for flexible movement
        let phase = null;
        let speed = null;
        let ampX = null, ampY = null, ampZ = null;
        // Free-mode / gesture state
        let currentMode = 'shape'; // 'shape' or 'free'
        let lastGesture = null;
        
        // RGB7 animated palette state
        const RGB7_PALETTE = [
            [1.0, 0.18, 0.18], // warm red
            [1.0, 0.55, 0.18], // orange
            [1.0, 0.9, 0.2],   // yellow
            [0.22, 0.9, 0.3],  // green
            [0.0, 0.9, 0.9],   // cyan
            [0.18, 0.48, 1.0], // blue
            [0.95, 0.18, 0.9]  // magenta
        ];
        let rgb7Active = false;

        // --- 1. THREE.JS SETUP ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.05);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CAM_Z;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Create Geometry
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            // Initialize random positions
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                positions[i] = (Math.random() - 0.5) * 10;
                colors[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Initialize targetColors and motion parameters for smooth transitions
            targetColors = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < colors.length; i++) targetColors[i] = colors[i];

            phase = new Float32Array(PARTICLE_COUNT);
            speed = new Float32Array(PARTICLE_COUNT);
            ampX = new Float32Array(PARTICLE_COUNT);
            ampY = new Float32Array(PARTICLE_COUNT);
            ampZ = new Float32Array(PARTICLE_COUNT);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                phase[i] = Math.random() * Math.PI * 2;
                speed[i] = 0.6 + Math.random() * 2.0; // 0.6..2.6
                ampX[i] = 0.02 + Math.random() * 0.18; // subtle horizontal wiggle
                ampY[i] = 0.01 + Math.random() * 0.12; // vertical smaller
                ampZ[i] = 0.02 + Math.random() * 0.18; // depth wiggle
            }

            // Shader Material for glowing dots
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            
            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: sprite,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Generate initial target
            generateTarget('sphere');

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // --- 2. SHAPE GENERATORS (MATH) ---
        function getPointOnSphere() {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = 2.5;
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        function getPointHeart() {
            const t = Math.random() * Math.PI * 2;
            const u = Math.random() * Math.PI; // distribution
            const r = 0.15; // Scale down
            // Parametric heart
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            const z = (Math.random()-0.5) * 4; // Thickness
            return { x: x*r, y: y*r, z: z*r };
        }

        function getPointSaturn() {
            const isRing = Math.random() > 0.6; // 40% planet, 60% ring
            if(!isRing) {
                // Planet Body
                const p = getPointOnSphere();
                return { x: p.x * 0.6, y: p.y * 0.6, z: p.z * 0.6 };
            } else {
                // Ring
                const angle = Math.random() * Math.PI * 2;
                const distance = 2.2 + Math.random() * 1.5;
                return {
                    x: Math.cos(angle) * distance,
                    y: (Math.random()-0.5) * 0.1, // Flat ring
                    z: Math.sin(angle) * distance
                };
            }
        }

        function getPointFlower() {
            // Rose curve logic
            const k = 4; // Petals
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const r = 2 + Math.cos(k * theta) + Math.sin(k * phi);
            
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi) * 0.5
            };
        }

        function getPointFireworks() {
             // Explosion simulation
             const theta = Math.random() * Math.PI * 2;
             const phi = Math.acos((Math.random() * 2) - 1);
             const r = Math.random() * 4; // Spread out volume
             return {
                 x: r * Math.sin(phi) * Math.cos(theta),
                 y: r * Math.sin(phi) * Math.sin(theta),
                 z: r * Math.cos(phi)
             };
        }

        // Additional simple generators for free-mode random shapes
        function getPointLaughFace() {
            // Approximate laughing face using particle clusters: rim, eyes, mouth
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;

            // Face rim
            const rFace = 2.2 + (Math.random() - 0.5) * 0.2;
            let x = rFace * Math.cos(theta);
            let y = rFace * Math.sin(theta) * 0.9;
            let z = (Math.random() - 0.5) * 0.4;

            // Eyes (two clusters)
            // left eye region approx at (-0.6, 0.6)
            if (Math.random() < 0.12) {
                const ex = -0.5 + (Math.random()-0.5)*0.12;
                const ey = 0.6 + (Math.random()-0.5)*0.08;
                const ez = (Math.random()-0.5)*0.1;
                return { x: ex, y: ey, z: ez };
            }
            if (Math.random() < 0.12) {
                const ex = 0.5 + (Math.random()-0.5)*0.12;
                const ey = 0.6 + (Math.random()-0.5)*0.08;
                const ez = (Math.random()-0.5)*0.1;
                return { x: ex, y: ey, z: ez };
            }

            // Mouth: cluster near bottom center in a smiling curve
            if (Math.random() < 0.18) {
                const a = Math.random() * Math.PI; // semicircle
                const mr = 0.9 + (Math.random()-0.5)*0.15;
                const mx = Math.cos(a) * mr * 0.6;
                const my = -0.5 + Math.sin(a) * 0.15;
                const mz = (Math.random()-0.5) * 0.08;
                return { x: mx, y: my, z: mz };
            }

            return { x: x, y: y, z: z };
        }

        function getPointCloud() {
            // Soft cloud: clustered Gaussians around a central point
            const cx = (Math.random()-0.5) * 0.6;
            const cy = (Math.random()-0.5) * 0.6;
            const cz = (Math.random()-0.5) * 0.6;
            const rx = (Math.random() - 0.5) * 1.5;
            const ry = (Math.random() - 0.5) * 0.9;
            const rz = (Math.random() - 0.5) * 1.0;
            return {
                x: cx + rx * Math.random(),
                y: cy + ry * Math.random(),
                z: cz + rz * Math.random()
            };
        }

        function getPointPlane() {
            const angle = Math.random() * Math.PI * 2;
            const width = 3.0 + Math.random() * 1.5;
            const thickness = 0.1 + Math.random() * 0.3;
            return {
                x: Math.cos(angle) * (Math.random() * width),
                y: (Math.random()-0.5) * thickness,
                z: Math.sin(angle) * (Math.random() * (width*0.6))
            };
        }

        function getPointCar() {
            // rectangular blob
            const w = 2 + Math.random() * 1.2;
            const h = 0.6 + Math.random() * 0.4;
            const d = 1 + Math.random() * 0.6;
            return {
                x: (Math.random()-0.5) * w,
                y: (Math.random()-0.5) * h - 0.2,
                z: (Math.random()-0.5) * d
            };
        }

        function getPointPerson() {
            // tall column with head
            const t = Math.random();
            if (t < 0.12) {
                // head
                return { x: (Math.random()-0.5)*0.25, y: 1.2 + Math.random()*0.15, z: (Math.random()-0.5)*0.25 };
            } else {
                // body/limbs
                return { x: (Math.random()-0.5)*0.45, y: (Math.random()-0.2)*1.0, z: (Math.random()-0.5)*0.45 };
            }
        }

        // --- 3. LOGIC CONTROLLER ---
        function setShape(shape, el) {
            currentShape = shape;
            // Mode switch: if user selects 'free', enter gesture-driven free mode
            if (shape === 'free') {
                currentMode = 'free';
                // initialize a loose random layout for free mode
                generateTarget('fireworks');
            } else {
                currentMode = 'shape';
                generateTarget(shape);
            }

            // Update button styles only for shape buttons
            document.querySelectorAll('#shape-panel button').forEach(b => b.classList.remove('active'));
            if (el && el.classList) el.classList.add('active');

            // Smoothly change color targets based on shape
            let c1, c2, c3;
            if(shape === 'heart') { c1=1; c2=0.2; c3=0.2; } // Red
            else if(shape === 'saturn') { c1=0.8; c2=0.6; c3=0.2; } // Gold
            else if(shape === 'flower') { c1=1; c2=0.5; c3=1; } // Pink
            else if(shape === 'sphere') { c1=0.2; c2=1; c3=1; } // Cyan
            else { c1=Math.random(); c2=Math.random(); c3=Math.random(); }

            for(let i=0; i<targetColors.length; i+=3) {
                targetColors[i] = c1 + (Math.random()-0.5)*0.2;
                targetColors[i+1] = c2 + (Math.random()-0.5)*0.2;
                targetColors[i+2] = c3 + (Math.random()-0.5)*0.2;
            }
        }

            // Apply a pleasing 7-color RGB palette across particles
            function setPalette(name) {
                if (!geometry) return;
                const colors = geometry.attributes.color.array;

                if (name === 'rgb7') {
                    // 7-color palette: red, orange, yellow, green, cyan, blue, magenta
                    const palette = [
                        [1.0, 0.18, 0.18], // warm red
                        [1.0, 0.55, 0.18], // orange
                        [1.0, 0.9, 0.2],   // yellow
                        [0.22, 0.9, 0.3],  // green
                        [0.0, 0.9, 0.9],   // cyan
                        [0.18, 0.48, 1.0], // blue
                        [0.95, 0.18, 0.9]  // magenta
                    ];

                        for (let i = 0; i < targetColors.length; i += 3) {
                            const pi = ((i / 3) % palette.length);
                            const base = palette[pi];
                            // seed initial targets; dynamic update will happen in `animate`
                            targetColors[i] = Math.min(1, Math.max(0, base[0] + (Math.random() - 0.5) * 0.08));
                            targetColors[i + 1] = Math.min(1, Math.max(0, base[1] + (Math.random() - 0.5) * 0.08));
                            targetColors[i + 2] = Math.min(1, Math.max(0, base[2] + (Math.random() - 0.5) * 0.08));
                        }

                        // enable animated rgb7 mode
                        rgb7Active = true;

                        // Update button active state (color panel only)
                        document.querySelectorAll('#color-panel .color-buttons button').forEach(b => b.classList.remove('active'));
                        const btn = document.getElementById('btn-rgb7');
                        if (btn) btn.classList.add('active');
                }
            else {
                // single-color palettes
                const map = {
                    'red': [1.0, 0.18, 0.18],
                    'cyan': [0.0, 0.9, 0.9],
                    'orange': [1.0, 0.55, 0.18],
                    'green': [0.22, 0.9, 0.3],
                    'blue': [0.18, 0.48, 1.0],
                    'purple': [0.75, 0.18, 0.9],
                    'white': [1.0, 1.0, 1.0],
                    'pink': [1.0, 0.4, 0.7]
                };

                const base = map[name] || [Math.random(), Math.random(), Math.random()];
                for (let i = 0; i < targetColors.length; i += 3) {
                    targetColors[i] = Math.min(1, Math.max(0, base[0] + (Math.random() - 0.5) * 0.06));
                    targetColors[i + 1] = Math.min(1, Math.max(0, base[1] + (Math.random() - 0.5) * 0.06));
                    targetColors[i + 2] = Math.min(1, Math.max(0, base[2] + (Math.random() - 0.5) * 0.06));
                }

                // disable rgb7 animated mode for single color palettes
                rgb7Active = false;

                document.querySelectorAll('#color-panel .color-buttons button').forEach(b => b.classList.remove('active'));
                const btn2 = document.getElementById('btn-' + name);
                if (btn2) btn2.classList.add('active');
            }
            }

        function generateTarget(shapeType) {
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                let p;
                switch(shapeType) {
                    case 'laugh': p = getPointLaughFace(); break;
                    case 'cloud': p = getPointCloud(); break;
                    case 'plane': p = getPointPlane(); break;
                    case 'car': p = getPointCar(); break;
                    case 'person': p = getPointPerson(); break;
                    case 'heart': p = getPointHeart(); break;
                    case 'saturn': p = getPointSaturn(); break;
                    case 'flower': p = getPointFlower(); break;
                    case 'fireworks': p = getPointFireworks(); break;
                    default: p = getPointOnSphere(); break;
                }
                targetPositions[i*3] = p.x;
                targetPositions[i*3+1] = p.y;
                targetPositions[i*3+2] = p.z;
            }
        }

        // --- 4. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            const positions = geometry.attributes.position.array;
            
            // Interaction Logic
            // If hand is detected, use handOpenness. If not, pulse automatically.
            const growthFactor = handPresent ? handOpenness : (Math.sin(time) * 0.2 + 0.8);
            
            // Smooth Rotation based on Hand Position or Auto-rotate
            if (handPresent) {
                particles.rotation.y += (handX * 2 - particles.rotation.y) * 0.05;
                particles.rotation.x += (-handY * 2 - particles.rotation.x) * 0.05;
            } else {
                particles.rotation.y += 0.002;
            }

            // Morphing Logic with per-particle flexible motion and color lerp
            const colors = geometry.attributes.color.array;
            // If rgb7 animated palette is active, update targetColors each frame with 1-second eased blends
            if (rgb7Active) {
                const p = RGB7_PALETTE;
                const plen = p.length;
                const tsec = Date.now() / 1000; // seconds
                const base = Math.floor(tsec) % plen;
                const next = (base + 1) % plen;
                const frac = tsec - Math.floor(tsec); // 0..1 within current second
                // cosine ease for smooth in/out
                const ease = 0.5 - 0.5 * Math.cos(frac * Math.PI);

                for (let k = 0, idx = 0; k < PARTICLE_COUNT; k++, idx += 3) {
                    // small per-particle phase offset to avoid rigid uniformity
                    const offset = ((k % plen) / plen - 0.5) * 0.12; // [-0.06..0.06]
                    let f2 = Math.min(1, Math.max(0, ease + offset));

                    targetColors[idx] = p[base][0] * (1 - f2) + p[next][0] * f2;
                    targetColors[idx + 1] = p[base][1] * (1 - f2) + p[next][1] * f2;
                    targetColors[idx + 2] = p[base][2] * (1 - f2) + p[next][2] * f2;
                }
            }
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const tx0 = targetPositions[ix];
                const ty0 = targetPositions[iy];
                const tz0 = targetPositions[iz];

                // Per-particle oscillation (flexible, organic motion)
                const s = speed[i];
                const ph = phase[i];
                // slightly different phases per axis
                const noiseX = Math.sin(time * s + ph) * ampX[i];
                const noiseY = Math.sin(time * s * 1.1 + ph * 1.3) * ampY[i];
                const noiseZ = Math.cos(time * s * 0.9 + ph * 0.7) * ampZ[i];

                // Optionally increase motion for 'fireworks'
                const fireBoost = currentShape === 'fireworks' ? 1.5 : 1.0;

                const tx = tx0 * growthFactor + noiseX * fireBoost;
                const ty = ty0 * growthFactor + noiseY * fireBoost;
                const tz = tz0 * growthFactor + noiseZ * fireBoost;

                // Smooth position lerp
                positions[ix] += ((tx) - positions[ix]) * 0.08;
                positions[iy] += ((ty) - positions[iy]) * 0.08;
                positions[iz] += ((tz) - positions[iz]) * 0.08;

                // Smooth color lerp toward targetColors
                colors[ix] += (targetColors[ix] - colors[ix]) * COLOR_LERP;
                colors[iy] += (targetColors[iy] - colors[iy]) * COLOR_LERP;
                colors[iz] += (targetColors[iz] - colors[iz]) * COLOR_LERP;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 5. HAND TRACKING SETUP (MediaPipe) ---
        const videoElement = document.getElementById('video-feed');
        const statusElement = document.getElementById('status');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handPresent = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Calculate Hand Position (Center of palm approx)
                // Wrist is index 0, Middle finger knuckle is index 9
                const wrist = landmarks[0];
                const middle = landmarks[9];
                
                // Map 0..1 to -1..1 coordinates
                // Note: Webcam X is mirrored
                handX = -((wrist.x + middle.x) / 2 - 0.5) * 4; 
                handY = -((wrist.y + middle.y) / 2 - 0.5) * 4;

                // 2. Calculate "Openness" (Growth)
                // Distance between thumb tip (4) and index tip (8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // Map distance: 0.05 (closed) to 0.4 (open) -> 0.1 to 2.5 scale
                handOpenness = Math.max(0.1, Math.min(2.5, distance * 8));

                // --- Simple gesture detection for free-mode ---
                // Thumb-index pinch
                const thumbIndexDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                // Average fingertip distance to wrist (tips: 4,8,12,16,20)
                const tips = [landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
                let sumTipToWrist = 0;
                for (let t of tips) sumTipToWrist += Math.hypot(t.x - wrist.x, t.y - wrist.y);
                const avgTipToWrist = sumTipToWrist / tips.length;

                // Heuristics thresholds (may need tuning per camera)
                const pinchThreshold = 0.06; // small -> pinch
                const fistThreshold = 0.07;  // small avg -> fist
                const openThreshold = 0.18;  // large avg -> open hand

                let gesture = null;
                if (thumbIndexDist < pinchThreshold) gesture = 'pinch';
                else if (avgTipToWrist < fistThreshold) gesture = 'fist';
                else if (avgTipToWrist > openThreshold) gesture = 'open';

                if (currentMode === 'free' && gesture && gesture !== lastGesture) {
                    lastGesture = gesture;
                    // Map gestures to shapes
                    if (gesture === 'pinch' || gesture === 'fist') {
                        // contract into ball (shrink only)
                        generateTarget('sphere');
                        currentShape = 'sphere';
                    } else if (gesture === 'open') {
                        // pick a random free-mode shape (laugh removed)
                        const freeChoices = ['saturn','person','plane','car','flower','cloud','fireworks'];
                        const pick = freeChoices[Math.floor(Math.random() * freeChoices.length)];
                        switch(pick) {
                            case 'cloud': generateTarget('cloud'); currentShape = 'cloud'; break;
                            case 'plane': generateTarget('plane'); currentShape = 'plane'; break;
                            case 'car': generateTarget('car'); currentShape = 'car'; break;
                            case 'person': generateTarget('person'); currentShape = 'person'; break;
                            default: generateTarget(pick); currentShape = pick; break;
                        }
                    }
                }

                statusElement.innerText = "Jari terdeteksi";
                statusElement.style.color = "#00ff00";
            } else {
                handPresent = false;
                statusElement.innerText = "Jari tidak terdeteksi";
                statusElement.style.color = "#aaa";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraFeed.start();
        
        // Start Three.js
        initThree();

    </script>
</body>
</html>